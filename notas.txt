							#################################
							# 	NOTAS DEL PROYECTO GREXCO	#		
							#################################

Conectar Mysql y Django: https://www.digitalocean.com/community/tutorials/how-to-create-a-django-app-and-connect-it-to-a-database

Conceder acceso a usuarios a Mysql: https://chartio.com/resources/tutorials/how-to-grant-all-privileges-on-a-database-in-mysql/

Crear Data base: CREATE DATABASE `my-db` CHARACTER SET utf8 COLLATE utf8_general_ci;	
Check Mysql services:
	$ sudo service mysql status
	$ sudo service mysql stop
	$ sudo service mysql start


******* Comandos Django **********
# Iniciar un proyecto 
$ django-admin.py startproject mysite

# Iniciar el servidor de Djando 
$ python manage.py runserver

# Para iniciar el servidor en el puerto 8080
$ python manage.py runserver 8080

# Para que este disponible para cualquier equipo de la red
$ python manage.py runserver 0.0.0.0:8000

# Para instalar mysqlclient
$ sudo apt-get install python3-dev libmysqlclient-dev
$ pip install mysqlclient

# Para crear una app 
$ python manage.py startapp aplicacion


******* Carpetas Django *********
- mysite/: Directorio que contiene el projecto. Se puede cambiar el nombre en cualquier momento sin afectar el proyecto.
- mysite/mysite/: Directorio del paquete que contiene el projecto. Es un paquete python y se usará para importar cualquier cosa dentro
                  de el.
- mysite/__init__.py: Un archivo requerido para que Python trate a este directorio como un paquete.
- mysite/settings.py: Opciones/configuraciones para este proyecto de Django.
- mysite/urls.py: La declaración de las URL para este proyecto de Django; una "tabla de contenidos".
- mysite/wsgi.py: El archivo encargado de ser compatible con el servidor web.


****** Registrar una aplicación ******
- En /my-site/my-site/settings.py :
	
	INSTALLED_APPS = [
		'django.contrib.admin',
	    'django.contrib.auth',
	    'django.contrib.contenttypes',
	    'django.contrib.sessions',
	    'django.contrib.messages',
	    'django.contrib.staticfiles',
	>>  'miApp.apps.miAppConfig', 
	]

>> Especifica el objeto de configuracion de 'mi aplicación (miApp)'. Este se generó en /my-site/miApp/apps.py


******** Migraciones *******
$ python manage.py makemigrations
$ python manage.py migrate


******** Shell para verificar los modelos ********
$ python manage.py shell


******** Enviar correos *********
from django.core.mail import send_mail
send_mail('Subject here', 'Here is the message.', 'from@example.com', ['to@example.com'], fail_silently=False)

- En settings.py:

EMAIL_HOST = 'smtp.gmail.com'
EMAIL_HOST_USER = 'miguel.mesa@grexco.com.co'
EMAIL_HOST_PASSWORD = 'grexco02'
EMAIL_PORT = 465
EMAIL_USE_TLS = False
EMAIL_USE_SSL = True


******** Sitio administrador **********
1. Se debe registrar los modelos de cada aplicación en el archivo admin.py correspondiente:

from .models import Author, Genre, Book, BookInstance

admin.site.register(Book)
admin.site.register(Author)
admin.site.register(Genre)
admin.site.register(BookInstance) 


******** Crear un super usuario ********
$ python manage.py createsuperuser

(grexco, grexco02)


******** Para que la aplicacion guarde la hora de la ciudad actual en la BD ********

	# Internationalization
	# https://docs.djangoproject.com/en/2.0/topics/i18n/

		LANGUAGE_CODE = 'en-us'

		TIME_ZONE = 'America/Bogota'

		USE_I18N = True

		USE_L10N = True

		USE_TZ = False


							#################################
							# FIN NOTAS DEL PROYECTO GREXCO	#		
							#################################


¿ QUE ES DJANGO ?
	Es un framework para aplicaciones web gratuito y open source, escrito en Python.

	- ¿ Por qué usar Django?:
		* Desarrollo ágil
		* Miles de herramientas
		* Seguro
		* Personalizable
		* Escalable
		* Flexible: No ata a una sola forma de hacer las cosas.


CREACION DE UN PROYECTO EN DJANGO
	
	1. Tener virtualenv
	2. $ pip install Django
	3. $ django-admin startproject 'Nombre del proyecto'  # Para iniciar un proyecto
		- Este crea una carpeta que contiene el proyecto.
		- La estructura de la carpeta es la siguiente:
			carpeta: Nombre del proyecto
				carpeta: Nombre del proyecto
					__init__.py 		# Para identificar la carpeta como un paquete de python.
					settings.py			# Configuraciones del proyecto.
					urls.py				# urls del proyecto.
					wsgi.py				# Archivo que permite desplegar el proyecto.
				manage.py 		# sirve para poner el proyecto dentro del path de Django. Contiene un listado
								# utilidades para manejar el proyecto.

	4. Cada proyecto de Django esta dividido por aplicaciones, estas dentro Django estan organizadas de tal manera que 
		tenemos miniaplicaciones dentro de una gran aplicacion, esto tiene las siguientes ventajas:
			 - Permite reusar las aplicaciones, con diferentes proyectos.
			 - Permite dividir la logica en paquetes más pequeños y esto nos ayuda a tener aplicacion mas robustas y 
			 	flexibles.
	5. $ python manage.py startapp 'Nombre de la aplicación' 	# Para crear una aplicación
		- Crea una carpeta nueva con el nombre de la aplicación y tiene la siguiente estructura:
			carpeta: Nombre de la aplicación
				carpeta: migrations		# Almacena las migraciones o cambios que se hagan a los modelos a lo largo de 
										# la historia del projecto. 
				__init__.py				# Paqete python.
				admin.py				# Para poder usasr el administrador de contenidos de Django.
				apps.py					# Contiene la configuracion de esta aplicación.
				models.py				# Contiene el mapeo entre los datos y la BD.
				test.py					# Para la pruebas unitarias
				views.py				# Para las vistas de la aplicación.m


CONFIGURACION DEL PROYECTO - settings.py - local_settings.py

	- DEBUG 			# Debe ser False en producción.
	- MIDDLEWARE 		# Permite activar o desactivar un MIDDLEWARE
	- ALLOWED_HOSTS		# En producción cuando DEBUG este False aca se deben colocar los Host o ips de Nuestras paginas,
						# Esto ofrece una protección contra ataques CSRF.
	- INSTALLED_APP		# Es donde están las aplicaciones instaladas (Registradas).
	- DATABASES			# Para configurar las BD. Es posible configurar varias BD.

	* Local settings: (Configuraciones para el ambiente de desarrollo.):
		Al final del archivo de configuraciones importar el archivo de configuraciones locales 'local_settings.py'.
		Django va a buscar las configuraciones del archivo local_settings.py si no lo encuentra va a usar las del archivo
		settings.py


QUE ES MVC Y MVC APLICADO A DJANGO

	MVC: Es un patron de desarrollo en el que:
		- Modelo representa la información y logica del negocio.
		- Vista representa dicha información al usuario.
		- Controlador en el mediador entres el modelo y la vista.

	Django usa un patron MVC modificado MVT (Modelo Vista Template):
		- (urls.py + views.py) == Controlador
		- models.py == Modelo
		- Controlador renderiza un HTML por medio de los templates de Django == Vista

		Servidor
		 _________________________________________________________
		|	 ___________                                          |
		|	| models.py |<-------¬ Consulta                       |
		| 	|___________|        |                                |
		|	 ____________________|_________              ______   |
		|	|  _________       __|_______  |	       	| HTML |------> Usuario
	 ---|-> | | urls.py | --> | views.py | | ---------> |______|  |		   |
	|	|	| |_________|     |__________| | Renderiza            |        |
	|	|	|______________________________|                      |        v
	|	|_________________________________________________________|     Request
	| 																	   |
	|______________________________________________________________________|


FUNCTION BASED VIEW 
	
	Vistas: Componente Django que procesa las solicitudes de los usuarios.
	
	 * Las vistas basadas en funciones permiten procesar las solicitudes del usuario a traves de funciones. Esta función
	 recibe un 'request' que luego se procesa y se retorna un 'HttpResponse'.

	 	- Request: Encapsula toda la informació n de la petición al servidor. Si hay parametros GET estos vienen dentro
		 			del request.
		- HttpResponse: Es un objeto (incluye a todas las clases que heredan de el) que corresponde a una respuesta http 
						por parte del servidor.

			Tipos de HttpResponse:
				- HttpResponse
				- JsonResponse: Para enviar datos en formato JSON cuando estoy haciendo un AJAX.
				- HttpResponseRedirect: Cuando se llegue a esta vista va a redireccionar a otro sitio.
				- HttpResponseBadRequest: Cuando los datos no son validos o la peticion esta mal formada.
	
	* Para los templates: Dentro de la aplicacion crear una carpeta templates y dentro de esta otra con el nombre de la
	aplicación, dentro de esta ultima van los templates de la aplicación, Django va a buscar dentro de la carpeta templates
	todos los templates por eso es mejor tenerlos separados dentro de estas por aplicaciones.

	** render(request, template, context)


CLASS BASED VIEW (views.py)

	Las Class Based Views son formas de procesar las solicitudes de los usuarios haciendo uso de clases.
	En este caso tendremos un clase que hereda de la clase View y que implementa al menos uno de estos metodos:
		-get
		- post
		- dispatch.

	CRUD Class Based Views:
		- CreateView: Se genera con un formulario y se crea un nuevo modelo.
		- UpdateView: Ya trae una instancia de un modelo y simplemente lo actualiza.
		- ListView: Hace un listado de los objetos de un modelo
		- DeleteView: Borra un objeto de un modelo.


USO DE TEMPLATES O MODELOS EN DJANGO 

	Los templates son la parte de la vista, haciendo relaciòn con el modelo MVC. 
	Los templates se deben guardar en una carpeta 'templates' dentro de cada aplicacion y dentro de esta 
	una carpeta con el nombre de la aplicacion a la que pertenece, dentro de esta ultima si deben ir los
	templates:

		mi_aplicacion/
			templates/
				mi_aplicacion/
					home.html 

	Cuando las vistas heredan de TemplateView usan la función get_context_data(self, *args, **kwargs)
	para enviar datos a los templates


Template tag y Template filter, filtros y etiquetas en Django (countries/tags.html)

	* template tag: empiezan con {%
	* template filter: empiezan con {{ (hacen una transformación sobre un valor que ya existe)

	El tag {% comment %} {% endcomment %} Es como un comentario, es decir lo que se coloque dentro
	de ese tag no se muestra cuando se renderize el HTML

	{% lorem %}  # Genera un lorem ipsum
	{% now "Formato" %}  # Genera la fecha actual y se puede pasar un formato 'Y-m-d'
	{% include %}  # Incluir un template dentro de otro
	{% extend %}  # Permite la herecia de templates

	{{ "PRUEBAS" | capfirst }}
	{{ variable | divisibleby:"3" }}  # Retorna True o False, pero no se debe hacer este tipo de logica
										en los templates, estos ya deberia venir pre procesado por la 
										vista


Context Processor (countries/context_processor.py)
	Podemos compartir variables en multiples templates. Definimos un diccionario y esos valores a 
	agregar a todos nuestros templates.

	** Cuando usarlos: Si esos mismos datos se usan en muchas vistas o todas las vistas.

	Estos context processors se encuentran en el archivo de settings.py en TEMPLATES. Algunos
	context processors definidos por Django son:

        'django.template.context_processors.debug', Util cuando estamos en modo debug porque muestra
													todas la variables disponibles
        'django.template.context_processors.request', 
        'django.contrib.auth.context_processors.auth',
        'django.contrib.messages.context_processors.messages',

	** Crear un context processor:
	   1. Crear un archivo context_processor.py dentro de la carpeta que contega mi aplicacion:

	   app/
	   	  __init__.py
		  admin.py
		  apps.py 
		  models.py 
		  test.py
		  views.py
	   >> context_processor.py 

	   Se crea un metodo en este archivo y luego se registra en settings.py 
	   Formato:
	        aplicacion.modulo.metodo

	   Use los datos del metodo context_processor en los templates home.html y tags.html


Herencia e inclusión / extend e include  (base.html)

Con los templates de Django hay dos opciones que permiten reducir la cantidad de código que 
debemos escribir:

	{% include %} -- Para incluir un template dentro de otro. Reusar el código de un template
	{% extends %} -- Para heredar de un template.

	** Extends:
		Se crea un template base (base.html) y dentro de este de secciones (bloques) en las cuales
		va a ir	el código de los otros templates, esto con:

			{% block content %}

			{% endblock %}

		Donde block es el tag de jinja y 'content' es el nombre que le asignamos a ese bloque, cuando 
		llamemos a este bloque desde otro template ese el nombre que debemos usar.

		Para heredar en home.html de base.html, la primera linea dentro de home debe ser:

			{% extends "ruta_a/base.html" %}

	** Include: (country.html)
		Si quiero mostrar el código de un template en otro template. Ejemplo:
			Tomo el código de country.html que me renderiza los paises (los datos los toma del 
			contexte processor, donde estan disponibles para todos los templates) y lo incluyo en
			home.html y tags.html, esto con:

				{% include "countries/country.html" %}

		
Ejercicio (Crear la aplicación continents)


Definiendo rutas (https://docs.djangoproject.com/en/2.0/topics/http/urls/)
	** Para pasar parametros en las URLs se usa <>:
	   path('url/<parametro>, mi_vista)

	Ejemplo:
		path('articles/<int:year>/', views.year_archive)

		Donde <int: > puede ser:
			str: para un string
			int: para un entero
			slug: para un slug

		Y < :year> es el nombre del parametro que va a recibir la vista

	** Para una vista que herede de TemplateView, la forma de recibir los datos de los parametros
	mediante la funcion get_context_data() es atravez de los **kwargs y estos son un diccionario:

		def get_context_data(self, *args, **kwargs):
		    variable = kwargs['nombre_parametro']


Name, Reverse (countries/home.html)
	
	** Name: Podemos definir un 'name' único para cada URL y referenciar este nombre en reemplazo 
	de la URL, de este modo el cambio de una URL no representa un cambio en toda la aplicación.

		path('url/<parametro>, mi_vista, name='nombre_de_la_URL')

	** Reverse: Para referenciar a estos names se puede usar:
		URL, dentro de los templates:

			<a href="{% url "nombre_de_la_URL" %}">Link</a>

			Si la url recibe parametros:

			<a href="{% url "nombre_de_la_URL" nombre_variable_de_url=valor %}">Link</a>

		Reverse, dentro del código: (context_processor.py, home.html), se usa el metodo reverse():
			
			from django.urls import reverse 
			reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None)

			colombia = {
				'name': 'Colombia',
				'code': 'CO',
				'url': reverse("country_detail_code", kwargs={'code', 'CO'})
			}
		
			y dentro de los templates se llama al atributo {{ }}


Include (geographic.urls) 
	Permite incluir varias urls a la vez, por lo general en Django cada aplicion debe tener sus propias 
	urls, para esto en cada carpeta de aplicacion se crea un archivo 'urls.py' y dentro de cada una
	de estas se crean las urls corresṕondientes para cada App.

	Puede ocurrir que tengamos dos nombre de ulrs iguales en dos aplicaciones diferentes por 
	ejemplo: continents y countries tienen dos url 'home'

	para separa esto en el archivo urls del proyecto se debe colocar un 'namespace' para difirenciar
	cada aplicacion

		path('url/', include('app.urls', namespace='name_app'))

	Esto va a colocar por defecto un nombre al metodo reverse(): ver 'countries:country_detail_code':

		'url': reverse("countries:country_detail_code", kwargs={'code', 'CO'})

	Para que funcione debe colocar una variable app_name dentro del urls.py de cada App 


Creando el primer modelo (countries.models)
	Los modelos son la capa intermedia entre la aplicación y la base de datos
	¿Que es?
		Es una fuente unica de información acerca de los datos. Contiene los campos esenciales 
		y comportamiento de los datos que se estan guardando, en general cada modelo mapea a una sola
		tabla de una base de datos.

		** Cada aplicación tiene sus propios modelos (models.py)

	Despues de crear los modelos es necesario hacer una migración para que django cree las tablas en la BD
	apartir de los modelos creados

		$ python manage.py makemigrations
			## Crea un archivo que contiene los datos de la migración dentro de la carpeta migrations de 
			cada aplicación

	Para aplicar la migración:

		$ python manage.py migrate
	
	Puedo interactuar con los modelos desde la consola con:

		$ python manage.py shell
		# He importar los modelos para usarlos

	** API de ORM de Django:

		>> Modelo.objects.all() == SELECT * FROM 


****************** 
Tener mucho cuidado con el app_name dentro de los urls.py
******************

API de los modelos en Django


Tipos de campos en los modelos de Django

	BooleanField
		Es un campo que guarda datos de tipo booleano, es decir False o True, es muy útil para
		establecer banderas de nuestro modelo, por ejemplo para establecer si nuestro modelo está
		activo o inactivo. Te recomiendo usar siempre el prefijo is o has para definir estos campos

		Ej:
			is_active = models.BooleanField(default=True)

	ForeignKey
		Un tipo de campo que establece la relación de uno a muchos hacia otro modelo, requiere
		tener el campo on_delete para establecer qué hacer cuando el objeto al que esta
		relacionado se elimina, también requiere el modelo al cual va a estar relacionado.
		
		Es uno de los tipos mas usados, algo que te recomiendo que hagas siempre es definir la
		relacion inversa a travez del campo related_name

		Ej:
			product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='products')

	DateTimeField
		Representa una fecha con hora. Es muy útil para guardar la fecha de creacion y modificacion
		de un modelo, usando los parametros:
			
			* auto_now_add -> automaticamente agrega la fecha actual al momento que se crea el objeto
			* auto_now -> automaticamente agrega la fecha actual cada vez que se modifica el objeto

			created_at = models.DateTimeField(auto_now_add=True)
			updated_at = models.DateTimeField(auto_now=True)

	EmailField
		Representa un correo, Valida que el texto guardado sea un email valido. Validar emails es mas
		dificil de lo que parece y django lo hace por ti, y lo hace muy bien.

			email = models.EmailField()

	ImageField
		Representa una imagen. Cuando se guarda una imagen, sube dicha imagen en nuestro
		media y almacena la url de dicha imagen

			avatar = models.ImageField()

	SlugField
		Representa una slug. Valida que el contenido guardado sea un slug valido,
		por defecto no valida si el slug es unico, asi que se suele usar con el flag unique=True

			slug = models.SlugField(unique=True)

	TextField
		Representa una texto, a diferencia del charfield, este no tiene limites en
		cuanto a cuantos caracteres puede guardar.

			content = models.TextField()

	ManyToManyField
		Representa una relacion de muchos a muchos, al igual que el foreingKey requiere
		el model al cual estara asociado como primer parametro, pero no requiere definir un on_delete. 
		Nunca es obligatorio ya que lo que hace este campo es crear un modelo intermedio con los
		ids de ambos modelos, por ende tambien recuerda que no puedes crear una relacion hasta que ambos
		campos esten guardados

			products = models.ManyToManyField(Product)

	OneToOneField
		Representa una relacion de uno a uno. Es equivalente a un foreignkey con un limite de una relacion

			father = models.OneToOneField(Person)

	** referencia completa: https://docs.djangoproject.com/es/2.0/ref/models/fields/
